function[]=saveporousgeom2Dtovtk(date,i,itmax,baseoutfilename,latticefolder,meshfolder,flags,N,Nx,Ny,lattice,spin)

%%
%        Project: Fluid - structure interaction on deformable surfaces
%         Author: Luca Di Stasio
%    Institution: ETH ZÃ¼rich
%                 Institute for Building Materials
% Research group: Computational Physics for Engineering Materials
%        Version: 0.1
%  Creation date: July 9th, 2014
%    Last update: July 9th, 2014
%
%    Description: 
%          Input: 
%         Output: 
%
%                 Ordering of flags:
%                 flags(1)  --> save data over fixed lattice (computational domain)
%                 flags(2)  --> save data over moving mesh (physical domain)
%                 flags(3)  --> save spin

%%

if i~=0
    idigits = fix(abs(log10(abs(i))))+1;
else
    idigits = 1;
end
if itmax~=0
    itmaxdigits = fix(abs(log10(abs(itmax))))+1;
else
    itmaxdigits = 1;
end
if idigits<itmaxdigits
    itstring = num2str(i);
    diffdigits = itmaxdigits - idigits;
    for i=1:diffdigits
        itstring = strcat('0',itstring);
    end
else
    itstring = '00';
end

Ncells = (Nx-1)*(Ny-1);
cells = generatecells2D(Nx,Ny);
cells(:,2:5) = cells(:,2:5) - 1;
   
if flags(1)
    % Create file

    latticefilename = strcat(latticefolder,'/',baseoutfilename,'_N',itstring,'.vtk');

    latticefid = fopen(latticefilename,'w');

    % Header
    % lines: 5
    % The first line simply describes the version number. The second line can contain what ever you want, for example a bit of information about who generated the file. The third simply determines the filetype: ASCII. The forth describes what kind of data VTK can expected in the rest of the file. There are five different types: Three structured types (STRUCTURED_POINTS, STRUCTURED_GRID, RECTILINEAR_GRID) in which all points somehow lineup or match, not very usable. One surface type (POLYDATA) which doesn't contain volume, not what we need. And finally UNSTRUCTURED_GRID which describes arbitrary combinations of all availible cells types. This is what we like.
    % The fifth line is empty.
    % --> Unstructured grid: 2D or 3D grid; for every grid point all three coordinates and for each grid cell all constituent points and the cell shape are given. XML file extension: *.vtu
    % --> Polygonal data:    2D grid; like the unstructured grid, but there are no polyhedra, but only flat polygons. Especially suited for maps (topography). XML file extension: *.vtp
    % --> Rectilinear grid:  3D grid; the grid cells are cuboids, so only the steps along the coordinate axes have to be given, but not the individual point coordinates or the connectivity.
    % --> Structured grid:   3D grid; here, all point coordinates are given, but the connectivity is omitted.
    % --> Structured points: Like the rectilinear grid, but the spacing between the points is equidistant; so only the origin and the spacing has to be given, not the point coordinates.

    fprintf(latticefid,'# vtk DataFile Version 6.0\n');
    fprintf(latticefid,strcat('Data over lattice in computational domain. Generated by Luca Di Stasio, Computational Physics of Engineering Materials, Institute for Building Materials, ETH Zuerich on ',date,'\n'));
    fprintf(latticefid,'ASCII\n');
    fprintf(latticefid,'DATASET STRUCTURED_GRID');
    fprintf(latticefid,' \n');

    % Pointdata
    % lines: #nr_points+2
    % The first line notes how many points there will be ("9") and in which format they'll be supplied (usually "FLOAT"). Nine lines follow, each line containing the xyz-coordinates of a point.
    % Based on this list, each point is assigned an id. The first point has id 0, the second point id 1, and so forth, till the last point with id 8.
    % The last line is empty.

    fprintf(latticefid,'DIMENSIONS %d %d\n',Nx,Ny);
    fprintf(latticefid,'POINTS %d FLOAT\n',N);
    for i=1:N
        fprintf(latticefid,'%12.8f %12.8f\n',lattice(i,1),lattice(i,2));
    end
    fprintf(latticefid,' \n');
    
    % Celldata
    % lines: #nr_cells+5
    % The first line notes how many cells there will be ("4") and how many numbers total will be supplied in the CELLS-block ("20"). Four lines follow, each line containing the information for a cell.
    % Each cell line starts with a number saying how many point-ids are to be read in that line followed by the list of those point-ids.
    % Based on this list, each cell is assigned an id. The first cell has id 0, the second id 1, and so forth, till the last cell with id 3.
    % After all cells have been given points, the cell types have to be set.
    % This is done in the CELL_TYPES-block.
    % The CELL_TYPES-line says how many cell-types are to be set. This number has to be the same as the number in the CELLS-line ("4"). The following line is a list of cell-types that are assigned to all cells. The first cell is of type "9", so ist the second cell and so forth.
    % The last line is empty.

    % Pointdatasets
    % lines: #nr_datasets*(#nr_points +3)+1
    % In this segment of the file, datasets that are associated to the points of the grid can be given. The data can either be of scalar- or vector-type.
    % The first line initiates that pointdata will be supplied in the following lines, the "9" simply says how many points per dataset there are (yes, it's redundant).
    % We seperate each of the datasets with an empty line. Each of the datasets has two leading lines followed by "9" lines of data.
    % The first dataset line specifies if "SCALAR"- or "VECTOR"-data will follow. It also assigns a name to the dataset ("HorizontalSpeed" , "Temperature"). The "FLOAT" specifies the format of the data. "FLOAT" will most likely always be good enough.
    % The second line has to do with color tables and "LOOKUP_TABLE default" will most likely be the only setting you will ever need.
    % The following "9" lines will either contain per line a scalar-value or a vector-value (consisting of 3 numbers).
    % The last line is empty.

    if any(flags(3:end)==1)
        fprintf(latticefid,'POINT_DATA %d\n',N);
    end
    if flags(3)
        fprintf(latticefid,'SCALARS Spin FLOAT\n');
        fprintf(latticefid,'LOOKUP_TABLE default\n');
        for i=1:N
            fprintf(latticefid,'%12.8f\n',spin(i));
        end
        fprintf(latticefid,' \n');
    end
    % Celldatasets
    % lines: #nr_datasets*(#nr_cells +3)+1
    % Exactly the same setup as the point-data, only this data is assigned to cells. 

    % Close file

    fclose(latticefid);
end

if flags(2)
    % Create file
    
    meshfilename = strcat(meshfolder,'/',baseoutfilename,'_N',itstring,'.vtk');

    meshfid = fopen(meshfilename,'w');

    % Header
    % lines: 5
    % The first line simply describes the version number. The second line can contain what ever you want, for example a bit of information about who generated the file. The third simply determines the filetype: ASCII. The forth describes what kind of data VTK can expected in the rest of the file. There are five different types: Three structured types (STRUCTURED_POINTS, STRUCTURED_GRID, RECTILINEAR_GRID) in which all points somehow lineup or match, not very usable. One surface type (POLYDATA) which doesn't contain volume, not what we need. And finally UNSTRUCTURED_GRID which describes arbitrary combinations of all availible cells types. This is what we like.
    % The fifth line is empty.
    % --> Unstructured grid: 2D or 3D grid; for every grid point all three coordinates and for each grid cell all constituent points and the cell shape are given. XML file extension: *.vtu
    % --> Polygonal data:    2D grid; like the unstructured grid, but there are no polyhedra, but only flat polygons. Especially suited for maps (topography). XML file extension: *.vtp
    % --> Rectilinear grid:  3D grid; the grid cells are cuboids, so only the steps along the coordinate axes have to be given, but not the individual point coordinates or the connectivity.
    % --> Structured grid:   3D grid; here, all point coordinates are given, but the connectivity is omitted.
    % --> Structured points: Like the rectilinear grid, but the spacing between the points is equidistant; so only the origin and the spacing has to be given, not the point coordinates.

    fprintf(meshfid,'# vtk DataFile Version 6.0\n');
    fprintf(meshfid,strcat('Data over mesh in physical domain. Generated by Luca Di Stasio, Computational Physics of Engineering Materials, Institute for Building Materials, ETH Zuerich on ',date,'\n'));
    fprintf(meshfid,'ASCII\n');
    fprintf(meshfid,'DATASET UNSTRUCTURED_GRID');
    fprintf(meshfid,' \n');

    % Pointdata
    % lines: #nr_points+2
    % The first line notes how many points there will be ("9") and in which format they'll be supplied (usually "FLOAT"). Nine lines follow, each line containing the xyz-coordinates of a point.
    % Based on this list, each point is assigned an id. The first point has id 0, the second point id 1, and so forth, till the last point with id 8.
    % The last line is empty.

    fprintf(meshfid,'POINTS %d FLOAT\n',N);
    for i=1:N
        fprintf(meshfid,'%12.8f %12.8f\n',lattice(i,5),lattice(i,6));
    end
    fprintf(meshfid,' \n');

    % Celldata
    % lines: #nr_cells+5
    % The first line notes how many cells there will be ("4") and how many numbers total will be supplied in the CELLS-block ("20"). Four lines follow, each line containing the information for a cell.
    % Each cell line starts with a number saying how many point-ids are to be read in that line followed by the list of those point-ids.
    % Based on this list, each cell is assigned an id. The first cell has id 0, the second id 1, and so forth, till the last cell with id 3.
    % After all cells have been given points, the cell types have to be set.
    % This is done in the CELL_TYPES-block.
    % The CELL_TYPES-line says how many cell-types are to be set. This number has to be the same as the number in the CELLS-line ("4"). The following line is a list of cell-types that are assigned to all cells. The first cell is of type "9", so ist the second cell and so forth.
    % The last line is empty.

    fprintf(meshfid,'CELLS %d %d\n',Ncells,Ncells*5);
    for i=1:Ncells
        fprintf(meshfid,'%d %d %d %d %d\n',cells(i,1),cells(i,2),cells(i,3),cells(i,4),cells(i,5));
    end
    fprintf(meshfid,' \n');

    fprintf(meshfid,'CELL_TYPES %d\n',Ncells);
    for i=1:Ncells
        fprintf(meshfid,'%d\n',9);
    end
    fprintf(meshfid,' \n');

    % Pointdatasets
    % lines: #nr_datasets*(#nr_points +3)+1
    % In this segment of the file, datasets that are associated to the points of the grid can be given. The data can either be of scalar- or vector-type.
    % The first line initiates that pointdata will be supplied in the following lines, the "9" simply says how many points per dataset there are (yes, it's redundant).
    % We seperate each of the datasets with an empty line. Each of the datasets has two leading lines followed by "9" lines of data.
    % The first dataset line specifies if "SCALAR"- or "VECTOR"-data will follow. It also assigns a name to the dataset ("HorizontalSpeed" , "Temperature"). The "FLOAT" specifies the format of the data. "FLOAT" will most likely always be good enough.
    % The second line has to do with color tables and "LOOKUP_TABLE default" will most likely be the only setting you will ever need.
    % The following "9" lines will either contain per line a scalar-value or a vector-value (consisting of 3 numbers).
    % The last line is empty.

    if any(flags(3:end)==1)
        fprintf(meshfid,'POINT_DATA %d\n',N);
    end
    if flags(3)
        fprintf(meshfid,'SCALARS Spin FLOAT\n');
        fprintf(meshfid,'LOOKUP_TABLE default\n');
        for i=1:N
            fprintf(meshfid,'%12.8f\n',spin(i));
        end
        fprintf(meshfid,' \n');
    end

    % Celldatasets
    % lines: #nr_datasets*(#nr_cells +3)+1
    % Exactly the same setup as the point-data, only this data is assigned to cells. 

    % Close file

    fclose(meshfid);

end

return