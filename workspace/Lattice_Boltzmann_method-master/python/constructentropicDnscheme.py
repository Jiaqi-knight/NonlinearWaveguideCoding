# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def constructentropicDnscheme(D=None,scheme1D=None,pruneflag=None,prunelevels=None,*args,**kwargs):
    varargin = constructentropicDnscheme.varargin
    nargin = constructentropicDnscheme.nargin

    ##
#        Project: Fluid - structure interaction on deformable surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: May 27th, 2014
#    Last update: May 27th, 2014
    
    #    Description: 
#          Input: 
#         Output:
    
    ##
    
    if nargin == 2:
        pruneflag=0
        prunelevels=- 1
    
    v1D=scheme1D[:,1:end() - 2]
    W1D=scheme1D[:,end() - 1]
    Q1D=size(v1D,1)
    scheme=matlabarray([])
    if pruneflag:
        if 2 == D:
            for i in arange(1,Q1D).reshape(-1):
                for j in arange(1,Q1D).reshape(-1):
                    prune=0
                    shell=round(v1D[i,1] ** 2 + v1D[j,1] ** 2)
                    level=1
                    while logical_not(prune) and level <= size(prunelevels,1):

                        if prunelevels[level,1] == shell:
                            prune=1
                            level=size(prunelevels,1) + 1
                        else:
                            level=level + 1

                    if logical_not(prune):
                        scheme=matlabarray(cat([scheme],[v1D[i,1],v1D[j,1],dot(W1D[i,1],W1D[j,1]),sqrt(v1D[i,1] ** 2 + v1D[j,1] ** 2)]))
        else:
            if 3 == D:
                for i in arange(1,Q1D).reshape(-1):
                    for j in arange(1,Q1D).reshape(-1):
                        for k in arange(1,Q1D).reshape(-1):
                            prune=0
                            shell=round(v1D[i,1] ** 2 + v1D[j,1] ** 2 + v1D[k,1] ** 2)
                            level=1
                            while logical_not(prune) and level <= size(prunelevels,1):

                                if prunelevels[level,1] == shell:
                                    prune=1
                                    level=size(prunelevels,1) + 1
                                else:
                                    level=level + 1

                            if logical_not(prune):
                                scheme=matlabarray(cat([scheme],[v1D[i,1],v1D[j,1],v1D[k,1],dot(dot(W1D[i,1],W1D[j,1]),W1D[k,1]),sqrt(v1D[i,1] ** 2 + v1D[j,1] ** 2 + v1D[k,1] ** 2)]))
    else:
        if 2 == D:
            for i in arange(1,Q1D).reshape(-1):
                for j in arange(1,Q1D).reshape(-1):
                    scheme=matlabarray(cat([scheme],[v1D[i,1],v1D[j,1],dot(W1D[i,1],W1D[j,1]),sqrt(v1D[i,1] ** 2 + v1D[j,1] ** 2)]))
        else:
            if 3 == D:
                for i in arange(1,Q1D).reshape(-1):
                    for j in arange(1,Q1D).reshape(-1):
                        for k in arange(1,Q1D).reshape(-1):
                            scheme=matlabarray(cat([scheme],[v1D[i,1],v1D[j,1],v1D[k,1],dot(dot(W1D[i,1],W1D[j,1]),W1D[k,1]),sqrt(v1D[i,1] ** 2 + v1D[j,1] ** 2 + v1D[k,1] ** 2)]))
    
    scheme=sortrows(scheme,size(scheme,2))
    QD=size(scheme,1)
    return scheme,QD