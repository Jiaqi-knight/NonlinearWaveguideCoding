
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>maxent_example</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-08-07"><meta name="DC.source" content="maxent_example.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">part 1: working with small distributions of neurons (exhaustively)</a></li><li><a href="#3">part 2: working with larger distributions of neurons (MCMC)</a></li><li><a href="#4">part 3: working with RP (random projection) models</a></li><li><a href="#5">part 4: specifying a custom list of correlations</a></li><li><a href="#6">part 5: constructing composite models</a></li><li><a href="#7">part 6: constructing and sampling from high order Markov chains</a></li></ul></div><pre class="codeinput"><span class="comment">% maxent_example.m</span>
<span class="comment">%</span>
<span class="comment">% Example code for the maximum entropy toolkit</span>
<span class="comment">% Ori Maoz, July 2016:  orimaoz@gmail.com,</span>


<span class="comment">%</span>
<span class="comment">% Note: all the "maxent." prefixes before the function calls can be omitted by commenting out the following line:</span>
<span class="comment">%import maxent.*</span>
</pre><h2 id="2">part 1: working with small distributions of neurons (exhaustively)</h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

<span class="comment">% create a k-pairwise model (pairwise maxent with synchrony constraints)</span>
model = maxent.createModel(ncells,<span class="string">'kising'</span>);

<span class="comment">% train the model to a threshold of one standard deviation from the error of computing the marginals.</span>
<span class="comment">% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states</span>
<span class="comment">% in memory and train the model in an exhaustive fashion.</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);

model_entropy = maxent.getEntropy(model);
fprintf(<span class="string">'Model entropy: %.03f   empirical dataset entropy: %.03f\n'</span>, model_entropy, empirical_distribution.entropy);

<span class="comment">% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions</span>
marginals_data = maxent.getEmpiricalMarginals(samples_test,model);
marginals_model = maxent.getMarginals(model);

<span class="comment">% plot them on a log scale</span>
figure
loglog(marginals_data,marginals_model,<span class="string">'b*'</span>);
hold <span class="string">on</span>;
minval = min([marginals_data(marginals_data&gt;0)]);
plot([minval 1],[minval 1],<span class="string">'-r'</span>); <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical marginal'</span>);
ylabel(<span class="string">'predicted marginal'</span>);
title(sprintf(<span class="string">'marginals in %d cells'</span>,ncells));
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
converged (marginals match)
Standard deviations from marginals: 0.097 (mean), 0.987 (max) [9]  DKL: 0.102
Kullback-Leibler divergence from test set: 0.098116
Model entropy: 6.464   empirical dataset entropy: 6.384
</pre><img vspace="5" hspace="5" src="maxent_example_01.png" alt=""> <h2 id="3">part 2: working with larger distributions of neurons (MCMC)</h2><pre class="codeinput">load <span class="string">example50</span>

<span class="comment">% randomly divide into train/test sets</span>
[ncells,nsamples] = size(spikes50);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes50(:,idx_train);
samples_test = spikes50(:,idx_test);

<span class="comment">% create a pairwise maximum entropy model</span>
model = maxent.createModel(50,<span class="string">'pairwise'</span>);

<span class="comment">% train the model to a threshold of 1.5 standard deviations from the error of computing the marginals.</span>
<span class="comment">% because the distribution is larger (50 dimensions) we cannot explicitly iterate over all 5^20 states</span>
<span class="comment">% in memory and will use markov chain monte carlo (MCMC) methods to obtain an approximation</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1.5);


<span class="comment">% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions.</span>
<span class="comment">% here the model marginals could not be computed exactly so they will be estimated using monte-carlo. We specify the</span>
<span class="comment">% number of samples we use so that their estimation will have the same amoutn noise as the empirical marginal values</span>
marginals_data = maxent.getEmpiricalMarginals(samples_test,model);
marginals_model = maxent.getMarginals(model,<span class="string">'nsamples'</span>,size(samples_test,2));

<span class="comment">% plot them on a log scale</span>
figure
loglog(marginals_data,marginals_model,<span class="string">'b*'</span>);
hold <span class="string">on</span>;
minval = min([marginals_data(marginals_data&gt;0)]);
plot([minval 1],[minval 1],<span class="string">'-r'</span>); <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical marginal'</span>);
ylabel(<span class="string">'predicted marginal'</span>);
title(sprintf(<span class="string">'marginals in %d cells'</span>,ncells));

<span class="comment">% the model that the MCMC solver returns is not normalized. If we want to compare the predicted and actual probabilities</span>
<span class="comment">% of individual firing patterns, we will need to first normalize the model. We will use the wang-landau algorithm for</span>
<span class="comment">% this. We chose parameters which are less strict than the default settings so that we will have a faster runtime.</span>
disp(<span class="string">'Normalizing model...'</span>);
model = maxent.wangLandau(model,<span class="string">'binsize'</span>,0.1,<span class="string">'depth'</span>,15);

<span class="comment">% the normalization factor was added to the model structure. Now that we have a normalized model, we'll use it to</span>
<span class="comment">% predict the frequency of activity patterns. We will start by observing all the patterns that repeated at least twice</span>
<span class="comment">% (because a pattern that repeated at least once may grossly overrepresent its probability and is not meaningful in this</span>
<span class="comment">% sort of analysis)</span>
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,<span class="string">'min_count'</span>,2);


<span class="comment">% get the model predictions for these patterns</span>
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

<span class="comment">% nplot on a log scale</span>
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,<span class="string">'bo'</span>);
hold <span class="string">on</span>;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],<span class="string">'-r'</span>);  <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical pattern log frequency'</span>);
ylabel(<span class="string">'predicted pattern log frequency'</span>);
title(sprintf(<span class="string">'activity pattern frequency in %d cells'</span>,ncells));



<span class="comment">% Wang-landau also approximated the model entropy, let's compare it to the entropy of the empirical dataset.</span>
<span class="comment">% for this we want to look at the entire set, not just the set limited repeating patterns</span>
empirical_distribution = maxent.getEmpiricalModel(samples_test);

<span class="comment">% it will not be surprising to see that the empirical entropy is much lower than the model, this is because the</span>
<span class="comment">% distribution is very undersampled</span>
fprintf(<span class="string">'Model entropy: %.03f bits, empirical entropy (test set): %.03f bits\n'</span>,model.entropy,empirical_distribution.entropy);

<span class="comment">% generate samples from the distribution and compute their entropy. This should give a result which is must closer to</span>
<span class="comment">% the entropy of the empirical distribution...</span>
samples_simulated = maxent.generateSamples(model,numel(idx_test));
simulated_empirical_distribution = maxent.getEmpiricalModel(samples_simulated);
fprintf(<span class="string">'Entropy of simulated data: %.03f bits\n'</span>,simulated_empirical_distribution.entropy);
</pre><pre class="codeoutput">Training to threshold: 1.500 standard deviations
Maximum samples: 17778   maximum MSE: 3.375
361/Inf samples=5466  MSE=6.504 (mean), 57.338 (max) [43]
436/Inf samples=11581  MSE=3.315 (mean), 66.423 (max) [2]
479/Inf samples=17778  MSE=2.391 (mean), 28.954 (max) [2]
514/Inf samples=17778  MSE=1.754 (mean), 22.708 (max) [40]
549/Inf samples=17778  MSE=1.699 (mean), 28.873 (max) [12]
584/Inf samples=17778  MSE=1.642 (mean), 11.995 (max) [45]
618/Inf samples=17778  MSE=1.716 (mean), 11.184 (max) [31]
652/Inf samples=17778  MSE=1.644 (mean), 10.448 (max) [1166]
686/Inf samples=17778  MSE=1.595 (mean), 8.928 (max) [1140]
721/Inf samples=17778  MSE=1.820 (mean), 7.465 (max) [40]
756/Inf samples=17778  MSE=1.508 (mean), 7.806 (max) [12]
791/Inf samples=17778  MSE=1.491 (mean), 9.723 (max) [12]
824/Inf samples=17778  MSE=1.521 (mean), 6.340 (max) [12]
857/Inf samples=17778  MSE=1.412 (mean), 4.215 (max) [675]
891/Inf samples=17778  MSE=1.541 (mean), 6.946 (max) [1264]
925/Inf samples=17778  MSE=1.511 (mean), 5.560 (max) [142]
960/Inf samples=17778  MSE=1.695 (mean), 7.271 (max) [1151]
996/Inf samples=17778  MSE=1.601 (mean), 5.649 (max) [1151]
1031/Inf samples=17778  MSE=1.464 (mean), 4.822 (max) [1151]
1066/Inf samples=17778  MSE=1.291 (mean), 6.976 (max) [410]
1102/Inf samples=17778  MSE=1.331 (mean), 3.873 (max) [23]
1138/Inf samples=17778  MSE=1.297 (mean), 3.436 (max) [258]
converged (marginals match)
Normalizing model...
[...............]
Model entropy: 17.527 bits, empirical entropy (test set): 11.978 bits
Entropy of simulated data: 12.490 bits
</pre><img vspace="5" hspace="5" src="maxent_example_02.png" alt=""> <img vspace="5" hspace="5" src="maxent_example_03.png" alt=""> <h2 id="4">part 3: working with RP (random projection) models</h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

<span class="comment">% create a random projection model with default settings</span>
model = maxent.createModel(ncells,<span class="string">'rp'</span>);

<span class="comment">% train the model to a threshold of one standard deviation from the error of computing the marginals.</span>
<span class="comment">% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states</span>
<span class="comment">% in memory and train the model in an exhaustive fashion.</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);

<span class="comment">% create a random projection model with a specified number of projections and specified average in-degree</span>
model = maxent.createModel(ncells,<span class="string">'rp'</span>,<span class="string">'nprojections'</span>,500,<span class="string">'indegree'</span>,4);

<span class="comment">% train the model</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
64/Inf  MSE=0.088 (mean), 4.981 (max) [65]  DKL: 0.122
134/Inf  MSE=0.014 (mean), 2.213 (max) [65]  DKL: 0.112
converged (marginals match)
Standard deviations from marginals: 0.072 (mean), 0.992 (max) [65]  DKL: 0.110
Kullback-Leibler divergence from test set: 0.125975
Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
09/Inf  MSE=56.463 (mean), 7086.771 (max) [69]  DKL: 0.243
29/Inf  MSE=0.644 (mean), 58.533 (max) [69]  DKL: 0.121
49/Inf  MSE=0.126 (mean), 15.019 (max) [364]  DKL: 0.108
69/Inf  MSE=0.075 (mean), 8.094 (max) [364]  DKL: 0.103
89/Inf  MSE=0.031 (mean), 3.065 (max) [364]  DKL: 0.100
109/Inf  MSE=0.022 (mean), 3.862 (max) [125]  DKL: 0.097
129/Inf  MSE=0.013 (mean), 2.741 (max) [125]  DKL: 0.095
149/Inf  MSE=0.008 (mean), 1.318 (max) [125]  DKL: 0.094
converged (marginals match)
Standard deviations from marginals: 0.083 (mean), 0.997 (max) [125]  DKL: 0.093
Kullback-Leibler divergence from test set: 0.108484
</pre><h2 id="5">part 4: specifying a custom list of correlations</h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);


<span class="comment">% create a model with first, second, and third-order correlations. (third-order model)</span>
<span class="comment">% we will do this by specifying a list of all the possible combinations of single factors, pairs and triplets</span>
correlations = cat(1,num2cell(nchoosek(1:ncells,1),2), <span class="keyword">...</span>
                num2cell(nchoosek(1:ncells,2),2),<span class="keyword">...</span>
                num2cell(nchoosek(1:ncells,3),2));

model = maxent.createModel(ncells,<span class="string">'highorder'</span>,correlations);

<span class="comment">% train it</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% use the model to predict the frequency of activity patterns.</span>
<span class="comment">% We will start by observing all the patterns that repeated at least twice (because a pattern that repeated at least</span>
<span class="comment">% once may grossly overrepresent its probability and is not meaningful in this sort of analysis)</span>
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,<span class="string">'min_count'</span>,2);

<span class="comment">% get the model predictions for these patterns</span>
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

<span class="comment">% nplot on a log scale</span>
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,<span class="string">'bo'</span>);
hold <span class="string">on</span>;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],<span class="string">'-r'</span>);  <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical pattern log frequency'</span>);
ylabel(<span class="string">'predicted pattern log frequency'</span>);
title(sprintf(<span class="string">'Third order model: activity patterns in %d cells'</span>,ncells));
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
26/Inf  MSE=3.765 (mean), 651.384 (max) [12]  DKL: 0.280
55/Inf  MSE=1.461 (mean), 42.061 (max) [8]  DKL: 0.145
84/Inf  MSE=0.555 (mean), 25.381 (max) [13]  DKL: 0.110
113/Inf  MSE=0.251 (mean), 20.876 (max) [2]  DKL: 0.098
142/Inf  MSE=0.125 (mean), 5.159 (max) [2]  DKL: 0.092
171/Inf  MSE=0.089 (mean), 5.211 (max) [278]  DKL: 0.089
199/Inf  MSE=0.047 (mean), 1.658 (max) [501]  DKL: 0.087
228/Inf  MSE=0.028 (mean), 1.828 (max) [12]  DKL: 0.085
255/Inf  MSE=0.025 (mean), 1.676 (max) [501]  DKL: 0.084
282/Inf  MSE=0.023 (mean), 1.690 (max) [501]  DKL: 0.083
converged (marginals match)
Standard deviations from marginals: 0.116 (mean), 0.990 (max) [501]  DKL: 0.083
</pre><img vspace="5" hspace="5" src="maxent_example_04.png" alt=""> <h2 id="6">part 5: constructing composite models</h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);


<span class="comment">% create a model with independent factors, k-synchrony and third-order correlations</span>
<span class="comment">% we will do this by initializing 3 separate models and then combining them to a single model</span>
third_order_correlations = num2cell(nchoosek(1:ncells,3),2);
model_indep = maxent.createModel(ncells,<span class="string">'indep'</span>);
model_ksync = maxent.createModel(ncells,<span class="string">'ksync'</span>);
model_thirdorder = maxent.createModel(ncells,<span class="string">'highorder'</span>,third_order_correlations);
model = maxent.createModel(ncells,<span class="string">'composite'</span>,{model_indep,model_ksync,model_thirdorder});

<span class="comment">% train it</span>
model = maxent.trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% use the model to predict the frequency of activity patterns.</span>
<span class="comment">% We will start by observing all the patterns that repeated at least twice (because a pattern that repeated at least</span>
<span class="comment">% once may grossly overrepresent its probability and is not meaningful in this sort of analysis)</span>
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,<span class="string">'min_count'</span>,2);

<span class="comment">% get the model predictions for these patterns</span>
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

<span class="comment">% nplot on a log scale</span>
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,<span class="string">'bo'</span>);
hold <span class="string">on</span>;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],<span class="string">'-r'</span>);  <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical pattern log frequency'</span>);
ylabel(<span class="string">'predicted pattern log frequency'</span>);
title(sprintf(<span class="string">'Composite model: activity patterns in %d cells'</span>,ncells));
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
30/Inf  MSE=0.484 (mean), 26.973 (max) [12]  DKL: 0.122
62/Inf  MSE=0.152 (mean), 4.076 (max) [24]  DKL: 0.111
94/Inf  MSE=0.062 (mean), 2.372 (max) [150]  DKL: 0.106
126/Inf  MSE=0.030 (mean), 1.534 (max) [458]  DKL: 0.104
159/Inf  MSE=0.025 (mean), 4.956 (max) [24]  DKL: 0.103
192/Inf  MSE=0.015 (mean), 1.924 (max) [24]  DKL: 0.101
225/Inf  MSE=0.011 (mean), 1.095 (max) [458]  DKL: 0.100
converged (marginals match)
Standard deviations from marginals: 0.097 (mean), 1.000 (max) [458]  DKL: 0.100
</pre><img vspace="5" hspace="5" src="maxent_example_05.png" alt=""> <h2 id="7">part 6: constructing and sampling from high order Markov chains</h2><p>train a time-dependent model</p><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15_spatiotemporal</span>

ncells = size(spikes15_time_dependent,1);
history_length = 2;


<span class="comment">% Create joint words of (x_t-2,x_t-1,x_t).</span>
xt = [];
<span class="keyword">for</span> i = 1:(history_length+1)
   xt = [xt;spikes15_time_dependent(:,i:(end-history_length-1+i))];
<span class="keyword">end</span>


<span class="comment">% create a spatiotemporal model that works on series of binary words: (x_t-2,x_t-1,x_t).</span>
<span class="comment">% this essentially describes the probability distribution as a second-order Markov process.</span>
<span class="comment">% We will model the distribution with a composite model that uses firing rates, total synchrony in the last 3 time bins</span>
<span class="comment">% and pairwise correlations within the current time bin and pairwise correlations between the current activity of a cell</span>
<span class="comment">% and the previous time bin.</span>
time_dependent_ncells = ncells*(history_length+1);
inner_model_indep = maxent.createModel(time_dependent_ncells,<span class="string">'indep'</span>);  <span class="comment">% firing rates</span>
inner_model_ksync = maxent.createModel(time_dependent_ncells,<span class="string">'ksync'</span>);  <span class="comment">% total synchrony in the population</span>
<span class="comment">% add pairwise correlations only within the current time bin</span>
second_order_correlations = num2cell(nchoosek(1:ncells,2),2);
temporal_matrix = reshape(1:time_dependent_ncells,[ncells,history_length+1]);
temporal_interactions = [];
<span class="comment">% add pairwise correlations from the current time bin to the previous time step</span>
<span class="keyword">for</span> i = 1:(history_length)
    temporal_interactions = [temporal_interactions;temporal_matrix(:,[i,i+1])];
<span class="keyword">end</span>
<span class="comment">% bunch of all this together into one probabilistic model</span>
temporal_interactions = num2cell(temporal_interactions,2);
inner_model_pairwise = maxent.createModel(time_dependent_ncells,<span class="string">'highorder'</span>,[second_order_correlations;temporal_interactions]);
mspatiotemporal = maxent.createModel(time_dependent_ncells,<span class="string">'composite'</span>,{inner_model_indep,inner_model_ksync,inner_model_pairwise});

<span class="comment">% train the model on the concatenated words</span>
disp(<span class="string">'training spatio-temporal model...'</span>);
mspatiotemporal = maxent.trainModel(mspatiotemporal,xt);


<span class="comment">% sample from the model by generating each sample according to the history.</span>
<span class="comment">% for this we need to generate the 3n-dimensional samples one by one, each time fixing two-thirds of the code word</span>
<span class="comment">% corresponding to time t-2 and t-1 and sampling only from time t.</span>
disp(<span class="string">'sampling from spatio-temporal model...'</span>);
x0 = uint32(xt(:,1));
xspatiotemporal = [];
nsamples = 10000;
<span class="keyword">for</span> i = 1:nsamples

    <span class="comment">% get next sample. we will use burn-in of 100 each step to ensure that we don't introduce time-dependent stuff</span>
    <span class="comment">% related to the sampling process itself.</span>
    xnext = maxent.generateSamples(mspatiotemporal,1,<span class="string">'fix_indices'</span>,1:(ncells*history_length),<span class="string">'burnin'</span>,100,<span class="string">'x0'</span>,x0);
    generated_sample = xnext(((ncells*history_length)+1):end,1);

    <span class="comment">% shift the "current" state by one time step</span>
    x0 = [x0((ncells+1):end,:);generated_sample];

    <span class="comment">% add the current output</span>
    xspatiotemporal = [xspatiotemporal,generated_sample];

<span class="keyword">end</span>


<span class="comment">% plot the result</span>
display_begin = 2000;
nsamples_to_display = 300;


<span class="comment">% plot the actual raster</span>
pos = [400,600,700,250];
figure(<span class="string">'Position'</span>,pos);
subplot(2,1,1);
pos = get(gca, <span class="string">'Position'</span>);pos(1) = 0.055;pos(3) = 0.9;set(gca, <span class="string">'Position'</span>, pos);
imshow(~spikes15_time_dependent(:,display_begin+(1:nsamples_to_display)));
title(<span class="string">'Actual data'</span>);

<span class="comment">% plot raster sampled from a spatiotemporal model</span>
subplot(2,1,2);
pos = get(gca, <span class="string">'Position'</span>);pos(1) = 0.055;pos(3) = 0.9;set(gca, <span class="string">'Position'</span>, pos);
imshow(~xspatiotemporal(:,display_begin+(1:nsamples_to_display)));
title(<span class="string">'Synthetic data (2nd-order Markov)'</span>);
</pre><pre class="codeoutput">training spatio-temporal model...
Training to threshold: 1.300 standard deviations
Maximum samples: 47335   maximum MSE: 2.535
283/Inf samples=2488  MSE=19.036 (mean), 47.786 (max) [48]
357/Inf samples=5250  MSE=9.391 (mean), 33.829 (max) [103]
401/Inf samples=8163  MSE=6.096 (mean), 21.037 (max) [212]
431/Inf samples=11016  MSE=4.558 (mean), 17.024 (max) [222]
455/Inf samples=14000  MSE=3.666 (mean), 10.921 (max) [52]
474/Inf samples=16923  MSE=3.058 (mean), 7.152 (max) [59]
490/Inf samples=19851  MSE=2.590 (mean), 7.018 (max) [99]
504/Inf samples=22824  MSE=2.239 (mean), 8.185 (max) [101]
516/Inf samples=25725  MSE=1.969 (mean), 9.438 (max) [101]
527/Inf samples=28707  MSE=1.797 (mean), 8.821 (max) [101]
537/Inf samples=31713  MSE=1.656 (mean), 7.257 (max) [101]
546/Inf samples=34690  MSE=1.598 (mean), 8.343 (max) [212]
554/Inf samples=37567  MSE=1.502 (mean), 8.692 (max) [212]
562/Inf samples=40683  MSE=1.403 (mean), 9.427 (max) [212]
570/Inf samples=44058  MSE=1.310 (mean), 9.120 (max) [212]
577/Inf samples=47239  MSE=1.227 (mean), 8.797 (max) [212]
584/Inf samples=47335  MSE=1.150 (mean), 8.708 (max) [212]
591/Inf samples=47335  MSE=1.082 (mean), 8.041 (max) [212]
598/Inf samples=47335  MSE=1.008 (mean), 7.813 (max) [212]
605/Inf samples=47335  MSE=0.978 (mean), 6.697 (max) [212]
612/Inf samples=47335  MSE=0.925 (mean), 5.669 (max) [212]
619/Inf samples=47335  MSE=0.902 (mean), 5.225 (max) [212]
626/Inf samples=47335  MSE=0.905 (mean), 4.294 (max) [212]
633/Inf samples=47335  MSE=0.908 (mean), 3.184 (max) [212]
converged (marginals match)
sampling from spatio-temporal model...
</pre><img vspace="5" hspace="5" src="maxent_example_06.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
% maxent_example.m
%
% Example code for the maximum entropy toolkit
% Ori Maoz, July 2016:  orimaoz@gmail.com,


%
% Note: all the "maxent." prefixes before the function calls can be omitted by commenting out the following line:
%import maxent.*

%% part 1: working with small distributions of neurons (exhaustively)

% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

% create a k-pairwise model (pairwise maxent with synchrony constraints)
model = maxent.createModel(ncells,'kising');

% train the model to a threshold of one standard deviation from the error of computing the marginals.
% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states 
% in memory and train the model in an exhaustive fashion.
model = maxent.trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);

model_entropy = maxent.getEntropy(model);
fprintf('Model entropy: %.03f   empirical dataset entropy: %.03f\n', model_entropy, empirical_distribution.entropy);

% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions
marginals_data = maxent.getEmpiricalMarginals(samples_test,model);
marginals_model = maxent.getMarginals(model);

% plot them on a log scale
figure
loglog(marginals_data,marginals_model,'b*');
hold on;
minval = min([marginals_data(marginals_data>0)]);
plot([minval 1],[minval 1],'-r'); % identity line
xlabel('empirical marginal');
ylabel('predicted marginal');
title(sprintf('marginals in %d cells',ncells));


%% part 2: working with larger distributions of neurons (MCMC)

load example50

% randomly divide into train/test sets
[ncells,nsamples] = size(spikes50);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes50(:,idx_train);
samples_test = spikes50(:,idx_test);

% create a pairwise maximum entropy model
model = maxent.createModel(50,'pairwise');

% train the model to a threshold of 1.5 standard deviations from the error of computing the marginals.
% because the distribution is larger (50 dimensions) we cannot explicitly iterate over all 5^20 states 
% in memory and will use markov chain monte carlo (MCMC) methods to obtain an approximation
model = maxent.trainModel(model,samples_train,'threshold',1.5);


% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions.
% here the model marginals could not be computed exactly so they will be estimated using monte-carlo. We specify the
% number of samples we use so that their estimation will have the same amoutn noise as the empirical marginal values
marginals_data = maxent.getEmpiricalMarginals(samples_test,model);
marginals_model = maxent.getMarginals(model,'nsamples',size(samples_test,2));

% plot them on a log scale
figure
loglog(marginals_data,marginals_model,'b*');
hold on;
minval = min([marginals_data(marginals_data>0)]);
plot([minval 1],[minval 1],'-r'); % identity line
xlabel('empirical marginal');
ylabel('predicted marginal');
title(sprintf('marginals in %d cells',ncells));

% the model that the MCMC solver returns is not normalized. If we want to compare the predicted and actual probabilities
% of individual firing patterns, we will need to first normalize the model. We will use the wang-landau algorithm for
% this. We chose parameters which are less strict than the default settings so that we will have a faster runtime.
disp('Normalizing model...');
model = maxent.wangLandau(model,'binsize',0.1,'depth',15);

% the normalization factor was added to the model structure. Now that we have a normalized model, we'll use it to
% predict the frequency of activity patterns. We will start by observing all the patterns that repeated at least twice
% (because a pattern that repeated at least once may grossly overrepresent its probability and is not meaningful in this
% sort of analysis)
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,'min_count',2);


% get the model predictions for these patterns
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

% nplot on a log scale
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,'bo');
hold on;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],'-r');  % identity line
xlabel('empirical pattern log frequency');
ylabel('predicted pattern log frequency');
title(sprintf('activity pattern frequency in %d cells',ncells));



% Wang-landau also approximated the model entropy, let's compare it to the entropy of the empirical dataset.
% for this we want to look at the entire set, not just the set limited repeating patterns
empirical_distribution = maxent.getEmpiricalModel(samples_test);

% it will not be surprising to see that the empirical entropy is much lower than the model, this is because the
% distribution is very undersampled
fprintf('Model entropy: %.03f bits, empirical entropy (test set): %.03f bits\n',model.entropy,empirical_distribution.entropy);

% generate samples from the distribution and compute their entropy. This should give a result which is must closer to
% the entropy of the empirical distribution...
samples_simulated = maxent.generateSamples(model,numel(idx_test));
simulated_empirical_distribution = maxent.getEmpiricalModel(samples_simulated);
fprintf('Entropy of simulated data: %.03f bits\n',simulated_empirical_distribution.entropy);



%% part 3: working with RP (random projection) models

% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

% create a random projection model with default settings
model = maxent.createModel(ncells,'rp');

% train the model to a threshold of one standard deviation from the error of computing the marginals.
% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states 
% in memory and train the model in an exhaustive fashion.
model = maxent.trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);

% create a random projection model with a specified number of projections and specified average in-degree
model = maxent.createModel(ncells,'rp','nprojections',500,'indegree',4);

% train the model
model = maxent.trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = maxent.getEmpiricalModel(samples_test);
model_logprobs = maxent.getLogProbability(model,empirical_distribution.words);
test_dkl = maxent.dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);


%% part 4: specifying a custom list of correlations

% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);


% create a model with first, second, and third-order correlations. (third-order model)
% we will do this by specifying a list of all the possible combinations of single factors, pairs and triplets
correlations = cat(1,num2cell(nchoosek(1:ncells,1),2), ...
                num2cell(nchoosek(1:ncells,2),2),...
                num2cell(nchoosek(1:ncells,3),2));

model = maxent.createModel(ncells,'highorder',correlations);
            
% train it
model = maxent.trainModel(model,samples_train,'threshold',1);

% use the model to predict the frequency of activity patterns. 
% We will start by observing all the patterns that repeated at least twice (because a pattern that repeated at least 
% once may grossly overrepresent its probability and is not meaningful in this sort of analysis)
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,'min_count',2);

% get the model predictions for these patterns
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

% nplot on a log scale
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,'bo');
hold on;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],'-r');  % identity line
xlabel('empirical pattern log frequency');
ylabel('predicted pattern log frequency');
title(sprintf('Third order model: activity patterns in %d cells',ncells));


%% part 5: constructing composite models


% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);


% create a model with independent factors, k-synchrony and third-order correlations
% we will do this by initializing 3 separate models and then combining them to a single model
third_order_correlations = num2cell(nchoosek(1:ncells,3),2);
model_indep = maxent.createModel(ncells,'indep');
model_ksync = maxent.createModel(ncells,'ksync');
model_thirdorder = maxent.createModel(ncells,'highorder',third_order_correlations);
model = maxent.createModel(ncells,'composite',{model_indep,model_ksync,model_thirdorder});
            
% train it
model = maxent.trainModel(model,samples_train,'threshold',1);

% use the model to predict the frequency of activity patterns. 
% We will start by observing all the patterns that repeated at least twice (because a pattern that repeated at least 
% once may grossly overrepresent its probability and is not meaningful in this sort of analysis)
limited_empirical_distribution = maxent.getEmpiricalModel(samples_test,'min_count',2);

% get the model predictions for these patterns
model_logprobs = maxent.getLogProbability(model,limited_empirical_distribution.words);

% nplot on a log scale
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,'bo');
hold on;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],'-r');  % identity line
xlabel('empirical pattern log frequency');
ylabel('predicted pattern log frequency');
title(sprintf('Composite model: activity patterns in %d cells',ncells));


%% part 6: constructing and sampling from high order Markov chains
% train a time-dependent model

% load spiking data of 15 neurons
load example15_spatiotemporal

ncells = size(spikes15_time_dependent,1);
history_length = 2;


% Create joint words of (x_t-2,x_t-1,x_t).
xt = [];
for i = 1:(history_length+1)   
   xt = [xt;spikes15_time_dependent(:,i:(end-history_length-1+i))];
end


% create a spatiotemporal model that works on series of binary words: (x_t-2,x_t-1,x_t).
% this essentially describes the probability distribution as a second-order Markov process.
% We will model the distribution with a composite model that uses firing rates, total synchrony in the last 3 time bins
% and pairwise correlations within the current time bin and pairwise correlations between the current activity of a cell
% and the previous time bin.
time_dependent_ncells = ncells*(history_length+1);
inner_model_indep = maxent.createModel(time_dependent_ncells,'indep');  % firing rates 
inner_model_ksync = maxent.createModel(time_dependent_ncells,'ksync');  % total synchrony in the population
% add pairwise correlations only within the current time bin
second_order_correlations = num2cell(nchoosek(1:ncells,2),2);
temporal_matrix = reshape(1:time_dependent_ncells,[ncells,history_length+1]);
temporal_interactions = [];
% add pairwise correlations from the current time bin to the previous time step
for i = 1:(history_length)
    temporal_interactions = [temporal_interactions;temporal_matrix(:,[i,i+1])];
end
% bunch of all this together into one probabilistic model
temporal_interactions = num2cell(temporal_interactions,2);
inner_model_pairwise = maxent.createModel(time_dependent_ncells,'highorder',[second_order_correlations;temporal_interactions]);
mspatiotemporal = maxent.createModel(time_dependent_ncells,'composite',{inner_model_indep,inner_model_ksync,inner_model_pairwise});

% train the model on the concatenated words
disp('training spatio-temporal model...');
mspatiotemporal = maxent.trainModel(mspatiotemporal,xt);


% sample from the model by generating each sample according to the history.
% for this we need to generate the 3n-dimensional samples one by one, each time fixing two-thirds of the code word
% corresponding to time t-2 and t-1 and sampling only from time t. 
disp('sampling from spatio-temporal model...');
x0 = uint32(xt(:,1));
xspatiotemporal = [];
nsamples = 10000;
for i = 1:nsamples
    
    % get next sample. we will use burn-in of 100 each step to ensure that we don't introduce time-dependent stuff
    % related to the sampling process itself.
    xnext = maxent.generateSamples(mspatiotemporal,1,'fix_indices',1:(ncells*history_length),'burnin',100,'x0',x0);    
    generated_sample = xnext(((ncells*history_length)+1):end,1);

    % shift the "current" state by one time step
    x0 = [x0((ncells+1):end,:);generated_sample];
    
    % add the current output 
    xspatiotemporal = [xspatiotemporal,generated_sample];
    
end


% plot the result
display_begin = 2000;
nsamples_to_display = 300;

    
% plot the actual raster
pos = [400,600,700,250];
figure('Position',pos);
subplot(2,1,1);
pos = get(gca, 'Position');pos(1) = 0.055;pos(3) = 0.9;set(gca, 'Position', pos);
imshow(~spikes15_time_dependent(:,display_begin+(1:nsamples_to_display)));
title('Actual data');

% plot raster sampled from a spatiotemporal model
subplot(2,1,2);
pos = get(gca, 'Position');pos(1) = 0.055;pos(3) = 0.9;set(gca, 'Position', pos);
imshow(~xspatiotemporal(:,display_begin+(1:nsamples_to_display)));
title('Synthetic data (2nd-order Markov)');


##### SOURCE END #####
--></body></html>