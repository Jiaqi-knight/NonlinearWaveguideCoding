
clear all
close all

%=============
% Code buckle_HCT
%
% buckling of a plate using the HCT element
%
% depends on HCT_buckle, HCT_wrinke
%=============

%-----
% input data
%-----

E_B = 1.0; % bending modulus
nu = 0.5; % Poisson ratio
ndiv = 3;  % discretization level
NQ = 7;      % quadrature order

shape = 2;
shape = 1;

%-----------------
% elliptical shape
%-----------------

if(shape==1)

 [ne,ng,p,c,efl,gfl] = trgl6_disk(ndiv);

 asp = 2.0;
 eps = (asp-1.0)/(asp+1.0);
 ax = 1+eps;
 ay = 1-eps;
 scale = sqrt(ax*ay)
 ax = ax/scale;
 ay = ay/scale;

  for i=1:ng
   p(i,1) = ax*p(i,1);
   p(i,2) = ay*p(i,2);
  end

end

%-------
% square
%-------

if(shape==2)

 [ne,ng,p,c,efl,gfl] = trgl6_sqr(ndiv);

end

%---------------------------------------------
% make sure the mid-nodes lie along the edges
%---------------------------------------------

for i=1:ne
 for j=1:2
  p(c(i,4),j)=0.5*( p(c(i,1),j)+p(c(i,2),j) );
  p(c(i,5),j)=0.5*( p(c(i,2),j)+p(c(i,3),j) );
  p(c(i,6),j)=0.5*( p(c(i,3),j)+p(c(i,1),j) );
 end
end

%--------------------------------------
% mark the global vertex and edge nodes
%--------------------------------------

for i=1:ne
  gfln(c(i,1)) = 0; gfln(c(i,2)) = 0; gfln(c(i,3)) = 0;  % vertex nodes
  gfln(c(i,4)) = 1; gfln(c(i,5)) = 1; gfln(c(i,6)) = 1;  % edge nodes
end

%--------
% count the number of global edge nodes
%-------

nge=0;  % number of edge nodes

for i=1:ng
 if(gfln(i) == 1)
   nge = nge+1;
   xpp(nge)=p(i,1); ypp(nge)=p(i,2);
 end
end

ic=0;
for i=1:ng
 if(gfln(i) == 0)
   ic=ic+1; xppp(ic)=p(i,1); yppp(ic)=p(i,2);
 end
end

%-----------------------------
% total number of global modes
%-----------------------------

ngv = ng-nge;     % vertex nodes

ngm = 3*ngv+nge;  % number of global modes

%------------------------------------------
% mark the position of the rows and columns
% of the modes corresponding to the global nodes
%------------------------------------------

for i=1:ng
  s(i) = 1;
  for j=1:i-1
   if(gfln(j) == 1)    % edge node, 1 dof
     s(i) = s(i)+1;
   else                % vertex node, 3 dofs
     s(i) = s(i)+3; 
   end
  end
end

%-----
% initialize the orientation index of the normal derivative
% at the midside nodes
%-----

for i=1:ng
 Idid(i) = 1;
end

%---------------------------------------------
% assemble the global bending stiffness matrix
% and rhs
%---------------------------------------------

gbsm = zeros(ngm,ngm); % initialize
grhs = zeros(ngm,ngm);    % right-hand side

area = 0;

for l=1:ne          % loop over the elements

% compute the element bending stiffness matrix and rhs

j1=c(l,1); j2=c(l,2); j3=c(l,3);   % global element labels
j4=c(l,4); j5=c(l,5); j6=c(l,6);

x1=p(j1,1); y1=p(j1,2);   % three vertices
x2=p(j2,1); y2=p(j2,2);
x3=p(j3,1); y3=p(j3,2);

%----- TENSIONS for an elliptical patch in shear flow:

if(shape==1)
 DN = (1-nu)*ax^2+2.0*ay^2;V1 =-2*ay^2/DN;V2 = -(1-nu)*ax^2/DN;
 txx1 = V1*x1; txx2 = V1*x2; txx3 = V1*x3;
 txy1 = V2*y1; txy2 = V2*y2; txy3 = V2*y3;
 tyy1 = nu*txx1; tyy2 = nu*txx2; tyy3 = nu*txx3;
 bfx = 1.0; bfy = 0.0;
end

%----- TENSIONS for a uniformly compressed square patch:

if(shape==2)
 txx1 =-1.0;txx2 =-1.0;txx3 =-1.0;
 txy1 = 0.0;txy2 = 0.0;txy3 = 0.0;
 tyy1 =-1.0;tyy2 =-1.0;tyy3 =-1.0;
 bfx = 0.0;bfy = 0.0;
end

%----- TENSIONS generated by code: MEMBRANE:

%txx1 = sigxx(l,1); txx2 = sigxx(l,2); txx3 = sigxx(l,3);
%txy1 = sigxy(l,1); txy2 = sigxy(l,2); txy3 = sigxy(l,3);
%tyy1 = sigyy(l,1); tyy2 = sigyy(l,2); tyy3 = sigyy(l,3);
%bfx = 1.0; bfy = 0.0;

%----- 

[ebsm_elm, rhs_elm, arel] = HCT_buckle ...
 ...
   (x1,y1, x2,y2, x3,y3, ...
   txx1,txx2,txx3,...
   txy1,txy2,txy3,...
   tyy1,tyy2,tyy3,...
   bfx, bfy, ...
   NQ, nu);

e(1) = s(j1); e(2) = s(j1)+1; e(3) = s(j1)+2;   % position in the global matrix
e(4) = s(j2); e(5) = s(j2)+1; e(6) = s(j2)+2;
e(7) = s(j3); e(8) = s(j3)+1; e(9) = s(j3)+2;
e(10)= s(j4); e(11)= s(j5);   e(12)= s(j6);

   for i=1:12

     fci = 1.0;
         if(i==10) fci = Idid(j4);
     elseif(i==11) fci = Idid(j5);
     elseif(i==12) fci = Idid(j6); end

     for j=1:12
      fcj = 1.0;
          if(j==10) fcj = Idid(j4);
      elseif(j==11) fcj = Idid(j5);
      elseif(j==12) fcj = Idid(j6); end
       gbsm(e(i),e(j)) = gbsm(e(i),e(j)) + fci*fcj*ebsm_elm(i,j);
       grhs(e(i),e(j)) = grhs(e(i),e(j)) - fci*fcj* rhs_elm(i,j);
     end
   end

 Idid(j4) = -1; Idid(j5) = -1; Idid(j6) = -1;

area = area+arel;

end

%---------------------------------------------------------
% remove the equations corresponding to the boundary nodes
%---------------------------------------------------------

Ic = 0;

for i=1:ng

 if(gfl(i,1) == 0)   % pick up the interior nodes

   Ic = Ic+1;
   for j=1:ngm
     gbsm(Ic,j) = gbsm(s(i),j);
     grhs(Ic,j) = grhs(s(i),j);
   end

   if(gfln(i) == 0)  % vertex node with 3 modes
     Ic = Ic+1;
     for j=1:ngm
        gbsm(Ic,j) = gbsm(s(i)+1,j);
        grhs(Ic,j) = grhs(s(i)+1,j);
     end
     Ic = Ic+1;
     for j=1:ngm
       gbsm(Ic,j) = gbsm(s(i)+2,j);
       grhs(Ic,j) = grhs(s(i)+2,j);
     end
   end

 end
end

ngm1 = Ic;

%---
% repeat for the columns:
%---

Ic = 0;

for i=1:ng

 if(gfl(i,1) == 0) % interior node

   Ic = Ic+1;
   for j=1:ngm1
     gbsm(j,Ic) = gbsm(j,s(i));
     grhs(j,Ic) = grhs(j,s(i));
   end

   if(gfln(i) == 0)  % vertex node
     Ic = Ic+1;
     for j=1:ngm1
       gbsm(j,Ic) = gbsm(j,s(i)+1);
       grhs(j,Ic) = grhs(j,s(i)+1);
     end
     Ic = Ic+1;
     for j=1:ngm1
       gbsm(j,Ic) = gbsm(j,s(i)+2);
       grhs(j,Ic) = grhs(j,s(i)+2);
     end
   end
 end
end

%----
% formulate the compact matrices
%---

for i=1:ngm1
 for j=1:ngm1
  gbsm1(i,j) = gbsm(i,j);
  grhs1(i,j) = grhs(i,j);
 end
end

%----
% Generalized eigenvalue problem
%
% E = eig(gbsm1,grhs1)
%----

%----
%
% Better method
%
gbsm1_inv = inv(gbsm1);
mat = gbsm1_inv*grhs1;
charval = eig(mat);

%---
% display the eigefunctions
%---

for mode=1:8
 figure(mode)
 hold on
 %axis square
 xlabel('x','fontsize',14)
 ylabel('y','fontsize',14)
 zlabel('f','fontsize',14)
 set(gca,'fontsize',14)
 box on
 view([23,26])

 eigenvalue = charval(mode)
 buckle_wrinkle (eigenvalue,ne,ng,c,p,gfl,gfln,ngm1,mat)
end

%---
% for shear flow over a circular patch
%---
%  E = E*(3-nu)/2;
%---

%----------------------------
%file1=fopen('buckle_matrix','w');
%  fprintf(file1, '%4.0f\n', ngm1);
%for i=1:ngm1
%  for j=1:ngm1
%  fprintf(file1, '%15.8f\n', mat(i,j));
%  end
%end
%fclose(file1);
%----------------------------
